import { useState } from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';
import { AnimatePresence } from 'framer-motion';
import { useLocalStorage } from './hooks/useLocalStorage';
import Header from './components/layout/Header';
import Home from './pages/Home';
import Footer from './components/layout/Footer';
import FirestoreEx from './pages/FirestoreEx';
import MapView from './pages/MapView';
import TermsOfService from './pages/TermsOfService';
import PrivacyPolicy from './pages/PrivacyPolicy';
import PlaceDisplay from './pages/PlaceDisplay';

// Load the example dataset from local file.
const seedRatingsData = require('./ratingsData.json');

// Define what the empty user scores form should look like. This is also used
// on form reset.
const emptyUserScores = [
  { name: 'Noise', score: 50, comment: '' },
  { name: 'Social', score: 50, comment: '' },
  { name: 'Coworking', score: 50, comment: '' },
  { name: 'Internet', score: 50, comment: '' },
  { name: 'Power', score: 50, comment: '' },
  { name: 'Accessibility', score: 50, comment: '' }
];

// Calculate the category average and return an array containing the new values.
const calculateCategoryAverageScores = (spotRatingData, formData) => {
  const categoryAverages = spotRatingData.categories.map((category, index) => {
    // Check that the current category matches the category of like index in
    // formData array. If the category names match, calculate the new average.
    if (category.name === formData[index].name) {
      // New average can be calculated using the formula:
      // newAverage = oldAverage + ((newValue - oldAverage) / newSize)
      // Reference: https://math.stackexchange.com/questions/22348/how-to-add-and-subtract-values-from-an-average
      let average =
        category.categoryAverage +
        (formData[index].score - category.categoryAverage) /
          (category.scores.length + 1);
      return {
        name: formData[index].name,
        categoryAverage: parseFloat(average.toFixed(3))
      };
    } else {
      return {};
    }
  });
  return categoryAverages;
};

// Calculate the spot average and return the new rating value.
const calculateSpotAverageScore = (spotRatingData) => {
  const categoriesArray = spotRatingData.categories;
  let spotAverage = categoriesArray.reduce(
    (average, category, index, array) => {
      average += category.categoryAverage;
      if (index === array.length - 1) {
        return parseFloat((average / array.length).toFixed(3));
      } else {
        return average;
      }
    },
    0
  );
  return spotAverage;
};

const App = () => {
  // A condition of use for infomation returned from the Google Places API is
  // that it is not stored or cached. Therefore the information returned from
  // the API will only be placed in the 'placesApiData' state temporarily and
  // cross-referenced with the data in 'ratingsData' state by checking the
  // 'place_id' field, of which storage is permitted.
  const [placesApiData, setPlacesApiData] = useState([]);
  // Provide an object containing form data for user ratings:
  const [userScores, setUserScores] = useState(emptyUserScores);
  const [currentPlace, setCurrentPlace] = useState({});
  // 'ratingsData' only retains information generated by this application, and
  // not the Google Places API:
  const [ratingsData, setRatingsData] = useLocalStorage(
    'ratingsData',
    seedRatingsData
  );

  // useLocation allows the application to keep track of its current location.
  // in this case it provides the necessary information for framer-motion to
  // animate on a per route (page-by-page) basis.
  // Note: for useLocation to function correctly the Router must be defined in
  // a higher level component (in this case index.js).
  const location = useLocation();

  const handleCurrentPlace = (addressObject) => {
    setCurrentPlace(addressObject);
    // NOTE: When querying the Google Places APIs the autocomplete API populates
    // place information where the geocoding API only returns address information.
    // If it is possible to associate the addressObject data with an existing
    // rating, it will be done below to minimise queries needed in the map section
    // of the application.
    // TODO - add code to populate 'placesApiData' where applicable.
  };

  // Determine which category in the userScores array needs to be updated and
  // replace with the new form data at that location.
  const handleScoreChange = (category, value) => {
    let newUserScores = userScores.map((score) => {
      if (score.name === category) {
        return {
          ...score,
          ...value
        };
      }
      return score;
    });
    setUserScores(newUserScores);
  };

  // Replace all current form elements with the 'emptyUserScores' object.
  const handleFormReset = (event) => {
    event.preventDefault();
    setUserScores(emptyUserScores);
  };

  // Determine which element in the ratingsData array needs to be appended to
  // and add the new ratings in their appropriate locations. New average rating
  // values are calculated at this stage.
  const handleScoresSubmit = (event) => {
    event.preventDefault();
    // Define which placeId the scores will be attributed to.
    let placeId = currentPlace.place_id;
    // Find the relevant rating in ratingsData.
    let newRatingData = ratingsData.filter(
      (rating) => rating.placeId === placeId
    )[0];

    // Calulate the new categoryAverage scores using the current rating for
    // this location along with the new information submitted in the form.
    console.log(
      'calculateCategoryAverageScores',
      calculateCategoryAverageScores(newRatingData, userScores)
    );

    // Update categoryAverage before calculating spotAverage.
    console.log(
      'calculateSpotAverageScore',
      calculateSpotAverageScore(newRatingData)
    );
    console.log('Rating Submit Button Press');
  };

  return (
    <>
      <Header
        currentPlace={currentPlace}
        handleCurrentPlace={handleCurrentPlace}
      />
      <main className="container">
        {/* The exitBeforeEnter prop prevents loading a new page before the last
        page has fully exited. */}
        <AnimatePresence exitBeforeEnter>
          {/* Location object and key added to the Routes component by means
          of the useLocation() hook. */}
          <Routes location={location} key={location.key}>
            <Route path="/" exact element={<Home />} />
            <Route
              path="/map"
              exact
              element={<MapView ratingsData={ratingsData} />}
            />
            <Route
              path="/spot/:placeid"
              exact
              element={
                <PlaceDisplay
                  currentPlace={currentPlace}
                  ratingsData={ratingsData}
                  userScores={userScores}
                  handleScoreChange={handleScoreChange}
                  handleFormReset={handleFormReset}
                  handleScoresSubmit={handleScoresSubmit}
                />
              }
            />
            <Route path="/terms" exact element={<TermsOfService />} />
            <Route path="/privacy" exact element={<PrivacyPolicy />} />
            <Route path="/firestore" exact element={<FirestoreEx />} />
          </Routes>
        </AnimatePresence>
      </main>
      <Footer />
    </>
  );
};

export default App;
