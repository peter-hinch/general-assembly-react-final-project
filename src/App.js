import { useState } from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';
import { AnimatePresence } from 'framer-motion';
import { useLocalStorage } from './hooks/useLocalStorage';
import Header from './components/layout/Header';
import Home from './pages/Home';
import Footer from './components/layout/Footer';
import MapView from './pages/MapView';
import TermsOfService from './pages/TermsOfService';
import PrivacyPolicy from './pages/PrivacyPolicy';
import PlaceDisplay from './pages/PlaceDisplay';

// Load the example dataset from local file.
const seedRatingsData = require('./ratingsData.json');

// Define what the empty user scores form should look like. This is also used
// on form reset.
const emptyUserScores = [
  { title: 'Noise', score: 50, comment: '' },
  { title: 'Social', score: 50, comment: '' },
  { title: 'Coworking', score: 50, comment: '' },
  { title: 'Internet', score: 50, comment: '' },
  { title: 'Power', score: 50, comment: '' },
  { title: 'Accessibility', score: 50, comment: '' }
];

// Calculate the category average and return an array containing the new values.
const calculateCategoryAverageScores = (spotRatingData, formData) => {
  const categoryAverages = spotRatingData.categories.map((category, index) => {
    // Check that the current category matches the category of like index in
    // formData array. If the category titles match, calculate the new average.
    if (category.title === formData[index].title) {
      // New average can be calculated using the formula:
      // newAverage = oldAverage + ((newValue - oldAverage) / newSize)
      // Reference: https://math.stackexchange.com/questions/22348/how-to-add-and-subtract-values-from-an-average
      let average =
        category.categoryAverage +
        (formData[index].score - category.categoryAverage) /
          (category.scores.length + 1);
      return {
        title: formData[index].title,
        categoryAverage: parseFloat(average.toFixed(3))
      };
    } else {
      return {};
    }
  });
  return categoryAverages;
};

// Calculate the spotAverage and return the new rating value.
const calculateSpotAverageScore = (spotRatingData) => {
  const categoriesArray = spotRatingData.categories;
  let spotAverage = categoriesArray.reduce(
    (average, category, index, array) => {
      average += category.categoryAverage;
      if (index === array.length - 1) {
        return parseFloat((average / array.length).toFixed(3));
      } else {
        return average;
      }
    },
    0
  );
  return spotAverage;
};

const App = () => {
  // A condition of use for infomation returned from the Google Places API is
  // that it is not stored or cached. Therefore the information returned from
  // the API will only be placed in the 'placesApiData' state temporarily and
  // cross-referenced with the data in 'ratingsData' state by checking the
  // 'place_id' field, of which storage is permitted.
  const [placesApiData, setPlacesApiData] = useState([]);
  // Provide an object containing form data for user ratings:
  const [userScores, setUserScores] = useState(emptyUserScores);
  const [currentPlace, setCurrentPlace] = useState({});
  // 'ratingsData' only retains information generated by this application, and
  // not the Google Places API:
  const [ratingsData, setRatingsData] = useLocalStorage(
    'ratingsData',
    seedRatingsData
  );

  // useLocation allows the application to keep track of its current location.
  // in this case it provides the necessary information for framer-motion to
  // animate on a per route (page-by-page) basis.
  // Note: for useLocation to function correctly the Router must be defined in
  // a higher level component (in this case index.js).
  const location = useLocation();

  const handleCurrentPlace = (addressObject) => {
    setCurrentPlace(addressObject);
    // NOTE: When querying the Google Places APIs the autocomplete API populates
    // place information where the geocoding API only returns address information.
    // If it is possible to associate the addressObject data with an existing
    // rating, it will be done below to minimise queries needed in the map section
    // of the application.
    // TODO - add code to populate 'placesApiData' where applicable.
    handleNewPlacesApiData(addressObject);
  };

  const handleNewPlacesApiData = (addressObject) => {
    setPlacesApiData((currentPlacesApiData) => [
      ...currentPlacesApiData,
      addressObject
    ]);
  };

  // Determine which category in the userScores array needs to be updated and
  // replace with the new form data at that location.
  const handleScoreChange = (category, value) => {
    let newUserScores = userScores.map((score) => {
      if (score.title === category) {
        return {
          ...score,
          ...value
        };
      }
      return score;
    });
    setUserScores(newUserScores);
  };

  // Replace all current form elements with the 'emptyUserScores' object.
  const handleFormReset = (event) => {
    event.preventDefault();
    setUserScores(emptyUserScores);
  };

  // Determine which element in the ratingsData array needs to be appended to
  // and add the new ratings in their appropriate locations. New average rating
  // values are also calculated at this stage.
  const handleScoresSubmit = (event) => {
    event.preventDefault();
    // Define which placeId the scores will be attributed to.
    let placeId = currentPlace.place_id;
    // Find the relevant rating in ratingsData.
    let newRatingData;
    if (ratingsData.hasOwnProperty(placeId)) {
      console.log('record exists');
      // Create a copy of ALL LEVELS of ratingsData[placeId] .
      newRatingData = {
        ...ratingsData[placeId],
        categories: [
          ...ratingsData[placeId].categories.map((category) => ({
            title: category.title,
            categoryAverage: category.categoryAverage,
            scores: [
              ...category.scores.map((score) => ({
                score: score.score,
                comment: score.comment
              }))
            ]
          }))
        ]
      };
    } else {
      console.log('record does not exist');
      // If there are no ratings data yet at this placeId, initialise an empty
      // ratings object. This allows the calculation of average scores to
      // function correctly.
      newRatingData = {
        spotAverage: 0,
        categories: [
          { title: 'Noise', categoryAverage: 0, scores: [] },
          { title: 'Social', categoryAverage: 0, scores: [] },
          { title: 'Coworking', categoryAverage: 0, scores: [] },
          { title: 'Internet', categoryAverage: 0, scores: [] },
          { title: 'Power', categoryAverage: 0, scores: [] },
          { title: 'Accessibility', categoryAverage: 0, scores: [] }
        ]
      };
    }

    // Calulate the new categoryAverage scores using the current rating for
    // this location along with the new information submitted in the form.
    const newCategoryAverageScores = calculateCategoryAverageScores(
      newRatingData,
      userScores
    );
    console.log('newCategoryAverageScores', newCategoryAverageScores);

    // Create a new object containing the updated user scores.
    newRatingData.categories.map((category, index) => {
      category.categoryAverage =
        newCategoryAverageScores[index].categoryAverage;
      category.scores = [
        ...category.scores,
        {
          score: parseFloat(userScores[index].score),
          comment: userScores[index].comment
        }
      ];
      return {
        title: category.title,
        categoryAverage: category.categoryAverage,
        scores: category.scores
      };
    });

    // Now that the new scores and categoryAverage values have been added,
    // calculate the new spotAverage score and add it to the newRatingData
    // object.
    newRatingData.spotAverage = calculateSpotAverageScore(newRatingData);

    // Insert newRatingData object back into the ratingsData object.
    setRatingsData({
      ...ratingsData,
      [placeId]: newRatingData
    });
    // Empty the form fields for the next review.
    setUserScores(emptyUserScores);
  };

  return (
    <>
      <Header
        currentPlace={currentPlace}
        handleCurrentPlace={handleCurrentPlace}
      />
      <main className="container">
        {/* The exitBeforeEnter prop prevents loading a new page before the last
        page has fully exited. */}
        <AnimatePresence exitBeforeEnter>
          {/* Location object and key added to the Routes component by means
          of the useLocation() hook. */}
          <Routes location={location} key={location.key}>
            <Route path="/" exact element={<Home />} />
            <Route
              path="/map"
              exact
              element={<MapView ratingsData={ratingsData} />}
            />
            <Route
              path="/spot/:placeId"
              exact
              element={
                <PlaceDisplay
                  currentPlace={currentPlace}
                  ratingsData={ratingsData}
                  userScores={userScores}
                  handleScoreChange={handleScoreChange}
                  handleFormReset={handleFormReset}
                  handleScoresSubmit={handleScoresSubmit}
                />
              }
            />
            <Route path="/terms" exact element={<TermsOfService />} />
            <Route path="/privacy" exact element={<PrivacyPolicy />} />
          </Routes>
        </AnimatePresence>
      </main>
      <Footer />
    </>
  );
};

export default App;
